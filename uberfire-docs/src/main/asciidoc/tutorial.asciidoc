= UberFire Tutorial
UberFire Community <uberfire@googlegroups.com>
:toc:
:source-highlighter: highlightjs
:stylesheet: asciidoctor.css
:link-suffix: .asciidoc

This guide will walk you through the process of setting up a new
UberFire application. Starting from an empty directory, you will
create a Maven `pom.xml` file to describe your project and its
dependencies, build up a simple application with client-side and
server-side behaviour, and learn how everything works along the way.

If you've never seen a full-blown working UberFire app before, why not
check out our link:quick-start{link-suffix}[Quick Start Guide] first?
It will help you get UberFire's pre-made showcase application up and
running on your system without getting bogged down in details.

This in-depth guide will be here waiting for you when you're ready to
scratch the surface and build something of your own.

So, assuming you're already familiar with what UberFire can do, let's
get started!

== Prerequisites

This guide assumes you have the following software set up and working
on your computer:

* http://www.oracle.com/technetwork/java/javase/downloads/index.html[A
  Java Development Kit (JDK) version 6 or newer]
* http://maven.apache.org/download.cgi[Maven 3.x]
* http://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/keplersr1[Eclipse IDE for Java EE Developers]
  Kepler SR1 or newer, or whatever Java IDE you like better (NetBeans,
  IntelliJ IDEA)

== Layout of a Typical UberFire Project

Your UberFire project will follow the standard Maven project
layout. Most open source Java projects follow this layout these days,
so this should look familiar. Here's a rundown of the specific files
and directories you'll find in every UberFire project. Don't get hung
up on the details yet. We'll get to each of these in turn.

pom.xml::
 Maven build configuration. Tells Maven and Java IDEs how to build
 your project.
src/main/java/::
 Java sources for both the server-side and client-side go here,
 organized into subdirectories by package, just like all Java
 projects require.
src/main/java/__com/mycompany/uftutorial__/UberFireTutorial.gwt.xml::
 GWT module declaration. Specifies GWT dependencies, which packages
 contain code destined for the client side, and (optionally) more.
src/main/java/__com/mycompany/uftutorial__/client/::
 Java package containing code that will be compiled to JavaScript (as
 configured in the `UberFireTutorial.gwt.xml` module descriptor) but
 not deployed in the WAR file (as configured in the `pom.xml`).
src/main/java/__com/mycompany/uftutorial__/client/css/::
 Stylesheets referred to by Errai UI's HTML templates. Will be copied
 into the webapp during the build.
src/main/java/__com/mycompany/uftutorial__/server/::
 Java package for code that will be deployed to the server but not
 compiled to JavaScript.
src/main/java/__com/mycompany/uftutorial__/shared/::
 Java package for code that will be deployed to the server _and_
 compiled to JavaScript for the client. Typically business model
 classes and event classes go in the shared package.
src/main/resources/::
 Normal Maven project location for resources that should be on the
 classpath. In GWT projects (which means UberFire projects too),
 `src/main/java` and `src/main/resources` are both defined as resource
 paths, so it's up to you whether you put resources here or under
 `src/main/java`.
src/main/resources/ErraiApp.properties::
 Marker file for the Errai framework. Errai uses this file to discover
 classpath locations that need to be scanned for Errai-annotated
 classes.  It's usually an empty file, but there are a number of
 https://docs.jboss.org/author/display/ERRAI/ErraiApp.properties[Errai
 framework settings] that can be placed here if necessary.
src/main/resources/simplelogger.properties::
 Configuration for the slf4j simple logger. We use this simple logger
 to avoid conflicts between our project's dev mode logging and the
 server-side logging, which is handled by JBoss Logging.
src/main/resources/META-INF/services/::
 Standard directory where Java extensions are configured via the
 `java.util.ServiceLoader` system.
src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider::
 The list of UberFire virtual filesystem (VFS) providers used in the
 application, one per line. Each entry is the fully-qualified name of
 a Java class that implements UberFire's `FileSystemProvider`
 interface. The first VFS provider listed is the default.
src/main/webapp/::
 The standard root directory for resources that will be bundled in the
 WAR file in any Maven-built web app project.
src/main/webapp/login.jsp::
 UberFire apps typically have a dedicated login page separate from the
 GWT application. This is that page.
src/main/webapp/tutorial.html::
 The host page for the UberFire GWT application. Simply put, a _GWT
 host page_ is a page with a `<script>` tag that loads the JavaScript
 generated by the GWT compiler. In a typical UberFire app, the host
 page is only served to users who are already logged in.
src/main/webapp/WEB-INF/::
 The standard directory where Java EE deployment descriptors, compiled
 Java classes, and third-party libraries go. You can also put your
 application's own non-public files under this directory. Files under
 this directory can be read by server-side code at runtime, but cannot
 be accessed by direct HTTP requests.
src/main/webapp/WEB-INF/beans.xml::
 Marker file for CDI. The existence of this file declares that the web
 application is CDI-enabled. The `beans.xml` file is left empty in
 simply CDI applications, but in UberFire applications, `beans.xml`
 normally defines some CDI interceptors that help enforce security
 rules.
src/main/webapp/WEB-INF/web.xml::
 Standard Java Servlets deployment descriptor. Defines the security
 filter, the Errai Servlet, and any additional servlets, security
 rules, and configuration required by your application's own code.
target/::
 Maven build steps write their output here. This directory and all its
 contents are completely removed whenever you execute `mvn clean`.

== Create an empty project in your IDE

Now that you've got an idea of what we're aiming for, let's get
started by creating a new project in your IDE of choice. This guide
provides instructions that were tested on Eclipse Kepler SR1, but if
you're comfortable in a different IDE, follow along and perform
similar steps in your own IDE.

1. Create a new Maven project using the *File -> New Maven Project...*
   menu. The ``New Maven Project'' wizard will appear.

2. Ensure the checkbox *Create a simple project (skip archetype
   selection)* is checked. Choose whatever location and working set
   you like, then press *Next*.

3. Enter the following values in the Artifact section of the form:
+
[horizontal]
Group Id::
  Anything you like. For example, *com.mycompany.uftutorial*
Artifact Id::
  Anything you like. For example, *uberfire-tutorial*
Version::
  Anything you like, as long as it ends in ``-SNAPSHOT''. For example, *0.0.1-SNAPSHOT*
Packaging::
  *war*
Name::
  Anything you like. For example, *UberFire Tutorial Project*.
Description::
  Anything you like. For example, *A project I'm creating from
  scratch in order to learn UberFire*

+
Ensure the Parent Project section is blank, then press *Finish*.

You should now have a project in your IDE workspace called
`uberfire-tutorial` which contains a skeletal `pom.xml` file.

== Fill in the Maven POM

The first thing you'll need is a Maven `pom.xml` file that describes
all the dependencies and special build steps of your project. If you
followed the instructions for Eclipse in the previous section, you
should have this:

[source,xml]
------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
     http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <modelVersion>4.0.0</modelVersion>
  <groupId>com.mycompany.uftutorial</groupId>
  <artifactId>uberfire-tutorial</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>war</packaging>
  <name>UberFire Tutorial Project</name>
  <description>A project Iâ€™m creating from scratch in order to learn UberFire</description>

</project>
------

Now let's define some properties that set up fundamental project
settings, such as source encoding, built-in Maven plugin versions, and
the version numbers of the UberFire and Errai frameworks we'll be
using. Add this inside the `<project>` element, after the
`<description>` tag:

[source,xml]
------
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <outputDirectory>${project.build.directory}/${project.artifactId}-${project.version}/WEB-INF/classes</outputDirectory>
    <maven.war.plugin.version>2.1.1</maven.war.plugin.version>
    <maven.clean.plugin.version>2.4.1</maven.clean.plugin.version>
    <maven.deploy.plugin.version>2.7</maven.deploy.plugin.version>
    <maven.resources.plugin.version>2.6</maven.resources.plugin.version>
    <maven.gwt.plugin.version>2.5.1</maven.gwt.plugin.version>
    <uberfire.version>0.5.0-SNAPSHOT</uberfire.version>
    <errai.version>3.0.4.Final</errai.version>
    <errai.devmode.version>${errai.version}</errai.devmode.version>
    <errai.jboss.home>${user.home}/wildfly-8.1.0.Final</errai.jboss.home>
    <jboss.spec.version>3.0.2.Final</jboss.spec.version>
    <slf4j.version>1.7.2</slf4j.version>
  </properties>
------

.Location of App Server
NOTE: this setup assumes you have downloaded and unzipped WildFly
8.1.0.Final into your home directory. If you have a different JBoss
app server on hand (JBoss EAP 6 or a different version of WildFly)
then change the `errai.jboss.home` property accordingly.

Now, after the properties section, we'll import four Maven _BOM_
files. BOM (short for Bill Of Materials) is a Maven technique (usage
pattern) where frameworks publish a comprehensive set of dependency
versions that are known to work well with the framework. We'll import
BOMs for UberFire, Errai, and the Java EE 6 API jars.

Note that importing a BOM doesn't add any actual dependencies to your
project; it simply manages the versions of the direct and transitive
dependencies you do add in the `<dependencies>` section further down.

This section can be placed right after the properties section from the
previous snippet:

[source,xml]
------
  <dependencyManagement>
    <dependencies>

      <dependency>
        <groupId>org.uberfire</groupId>
        <artifactId>uberfire-parent-with-dependencies</artifactId>
        <version>${uberfire.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.errai.bom</groupId>
        <artifactId>errai-version-master</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>

      <dependency>
        <groupId>org.jboss.errai</groupId>
        <artifactId>errai-parent</artifactId>
        <version>${errai.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      
      <dependency>
        <groupId>org.jboss.spec</groupId>
        <artifactId>jboss-javaee-6.0</artifactId>
        <version>${jboss.spec.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      
      <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>${slf4j.version}</version>
      </dependency>

      <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>${slf4j.version}</version>
      </dependency>
      
    </dependencies>
  </dependencyManagement>
------

Note that we've also included slf4j explicitly here. That is because
we're using slf4j-simple in this application, and slf4j-simple is not
included in any of the 4 BOMs. Thus, we're redefining the version of
slf4j-api to be sure the two artifacts are in sync.

So that takes care of pinning all the sensitive dependency
_versions_. Now let's declare the libraries we'll be using. Insert all
of this after the `<dependencyManagement>` section:

[source,xml]
------
  <dependencies>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-js</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-backend-cdi</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-server</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-security-client</artifactId>
      <scope>provided</scope>
    </dependency>
    
    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-security-picketlink</artifactId>
    </dependency>

    <dependency>
      <groupId>org.owasp.encoder</groupId>
      <artifactId>encoder</artifactId>
      <version>1.1.1</version>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-fs</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-nio2-jgit</artifactId>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-client-api</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-workbench-client</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-javaee-all</artifactId>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-cdi-jboss</artifactId>
      <version>${errai.devmode.version}</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.jboss.spec.javax.ejb</groupId>
      <artifactId>jboss-ejb-api_3.1_spec</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-simple</artifactId>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-annotation-processors</artifactId>
      <version>${errai.version}</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>org.uberfire</groupId>
      <artifactId>uberfire-workbench-processors</artifactId>
      <scope>provided</scope>
    </dependency>

    <!-- All of this stuff is supplied by the app server and must not
    be deployed with the WAR file! -->
    <dependency><groupId>org.slf4j</groupId><artifactId>slf4j-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>com.google.guava</groupId><artifactId>guava-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>hsqldb</groupId><artifactId>hsqldb</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.annotation</groupId><artifactId>jsr250-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.enterprise</groupId><artifactId>cdi-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.inject</groupId><artifactId>javax.inject</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>javax.validation</groupId><artifactId>validation-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>junit</groupId><artifactId>junit</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.common</groupId><artifactId>hibernate-commons-annotations</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate.javax.persistence</groupId><artifactId>hibernate-jpa-2.0-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-entitymanager</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.hibernate</groupId><artifactId>hibernate-validator</artifactId><classifier>sources</classifier><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-cdi-jetty</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-codegen-gwt</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-data-binding</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-ioc</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-ioc-bus-support</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-javax-enterprise</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jaxrs-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-jpa-client</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-navigation</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-tools</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.errai</groupId><artifactId>errai-ui</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.resteasy</groupId><artifactId>jaxrs-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.interceptor</groupId><artifactId>jboss-interceptors-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.spec.javax.transaction</groupId><artifactId>jboss-transaction-api_1.1_spec</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld.servlet</groupId><artifactId>weld-servlet-core</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-api</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>org.jboss.weld</groupId><artifactId>weld-spi</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>xml-apis</groupId><artifactId>xml-apis</artifactId><scope>provided</scope></dependency>
    <dependency><groupId>com.sun.xml.bind</groupId><artifactId>jaxb-impl</artifactId><scope>provided</scope></dependency>

    <!-- And finally, add this -->
    <dependency>
      <groupId>org.jboss.errai</groupId>
      <artifactId>errai-jboss-as-support</artifactId>
      <scope>compile</scope>
    </dependency>

    <dependency>
      <groupId>org.seleniumhq.selenium</groupId>
      <artifactId>selenium-java</artifactId>
      <scope>test</scope>
    </dependency>
    
    <!-- Required but not declared by selenium -->
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-exec</artifactId>
      <scope>test</scope>
    </dependency>

  </dependencies>
------

And that takes care of adding UberFire, Errai, and the Java EE 6 APIs
to the project. The big ugly list of provided-scope dependencies
toward the end is a necessary evil: these are the dependencies that we
inherit transitively from UberFire, Errai, and GWT which must not be
bundled in the WAR file. Maven does not provide a mechanism for
inheriting provided-scope transitive dependencies, so we have to list
them all here separately to ensure they are not bundled in the WAR.

[TIP]
.Extra Step for Eclipse Users
------
The uberfire-workbench-processors module includes Java annotation
processors that must run every time you compile your app's client-side
code. Netbeans, IntelliJ IDEA, and the Maven Compiler Plugin will all
discover and activate these annotation processors during
compilation. However, Eclipse has this feature turned off by
default. If you are using Eclipse, you have to
link:m2e-apt-setup{link-suffix}[set up the m2e-apt annotation
processing configurator] before developing an UberFire application.
------

Now on to the `<build>` section, where we define the behaviour of
several plugins we'll need in order to get the project built. The
`<build>` section can be placed after the `<dependencies>` section.

[source,xml]
------
  <build>

    <resources>
      <resource>
        <directory>src/main/java</directory>
      </resource>
      <resource>
        <directory>src/main/resources</directory>
      </resource>
    </resources>
    
    <outputDirectory>${outputDirectory}</outputDirectory>

    <plugins>
      <!-- see below in this guide -->
    </plugins>

  </build>
------

The `<resources>` section adds `src/main/java` and reaffirms that
`src/main/resources` is also a resource directory.

The purpose of adding `src/main/java` as a resource directory is to
ensure all the .java source files are included on the classpath. The
GWT compiler requires this.

The reason we add `src/main/resources` redundantly is because the
Maven integration in IntelliJ IDEA does not retain this default
resource directory when you add a new one. Adding it explicitly
provides maximum compatibility.

Now, speaking of the GWT compiler, we need to invoke it during our
project's build. How do we teach Maven to do this and other build
steps that are unique to an UberFire-based project? That's where Maven
plugins come in.

Note that all of the following `<plugin>` elements go _inside_ the
`<plugins>` placeholder we defined in the previous step.

First up, we'll define some settings for `maven-compiler-plugin`:

[source,xml]
------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>2.4</version>
        <configuration>
          <source>1.6</source>
          <target>1.6</target>
        </configuration>
      </plugin>
------

The `source` and `target` options set the compiler for Java 1.6
compliance. This is the version of the Java language that GWT 2.5.x
supports.

Now we will use `build-helper-maven-plugin` to add the
`generated-sources` directory as a source directory within our
project. This makes the generated sources and their corresponding
compiled classes visible to GWT's Dev Mode:

[source,xml]
------
      <!-- Put the generated sources from annotation processing on the
      classpath so GWT Dev Mode can see them -->
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>1.7</version>
        <executions>
          <execution>
            <id>add-source</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>add-source</goal>
            </goals>
            <configuration>
              <sources>
                <source>target/generated-sources/annotations</source>
              </sources>
            </configuration>
          </execution>
        </executions>
      </plugin>
------

Next up, the all-important `gwt-maven-plugin`.

[source,xml]
------
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>gwt-maven-plugin</artifactId>
        <version>${maven.gwt.plugin.version}</version>
        <configuration>

          <server>org.jboss.errai.cdi.server.gwt.JBossLauncher</server>

          <!-- Change to false if using client-side Bean Validation -->
          <strict>true</strict>

          <!-- If you can't use strict mode, diagnose mysterious
               rebind errors by setting this to DEBUG -->
          <logLevel>INFO</logLevel>

          <runTarget>${project.artifactId}</runTarget>

          <!-- do not insert line breaks in this string; it breaks Windows compatibility -->
          <extraJvmArgs>-Xmx1g -Xms756m -XX:MaxPermSize=256m -XX:CompileThreshold=1000 -Derrai.jboss.home=${errai.jboss.home} "-Derrai.jboss.javaopts=-XX:MaxPermSize=256m -Dorg.jboss.weld.nonPortableMode=true" -Derrai.dev.context=${project.artifactId} -Derrai.jboss.javaagent.path=${settings.localRepository}/org/jboss/errai/errai-client-local-class-hider/${errai.devmode.version}/errai-client-local-class-hider-${errai.devmode.version}.jar=classPattern=${project.groupId}.client/.*</extraJvmArgs>

        </configuration>
        <executions>
          <execution>
          <id>gwt-compile</id>
            <goals>
              <goal>resources</goal>
              <goal>compile</goal>
            </goals>
          </execution>
          <execution>
            <id>gwt-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>clean</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
------

This is a lot to digest. Let's take it one step at a time.

First, we configure GWT to use Errai's `JBossLauncher`, which manages
deployment of your webapp to a real JBoss EAP or WildFly instance. We
don't want Dev Mode to start its embedded Jetty 6 server, because that
makes it difficult to set up CDI, JPA, and other features that work
well with UberFire and Errai.

Next, we enable GWT's strict mode. This causes the build to fail with
a helpful error message when you use Java APIs that aren't available
in GWT's in-browser runtime environment (GWT calls this
_non-translatable_ code). Without strict mode, these errors will show
up later in the compile in a way that gives you no clue what happened.

NOTE: There is a caveat to using strict mode: it is not compatible
with client-side Bean Validation, so you will have to turn it off when
and if you start using Bean Validation in your app's client-side
code. The inferior alternatve to strict mode is to set Dev Mode's
`logLevel` to `DEBUG` and sift through the output for clues about
non-translatable code. But we don't have to worry about that at this
point.

Moving on, we set `runTarget` to the local URL where your webapp will
be served by the JBoss EAP or WildFly server on your workstation.

The `extraJvmArgs` setting passes some information to Errai's
`JBossLauncher`, increases the memory limits for the Dev Mode JVM, and
asks its JIT compiler to be more aggressive in generating native
code. We've done some experimenting and found a compile threshold of
1000 allows Dev Mode to start up a little faster.

Putting Weld (the CDI implementation in WildFly) into non-portable
mode allows an UberFire CDI extension that was designed for CDI 1.0 to
continue to work in newer Weld containers, which implement CDI
1.1. This is a stopgap solution until a permanent fix for
https://issues.jboss.org/browse/UF-133[UF-133] is found.

The `errai-client-local-class-hider` is a Java agent that strips out
the contents of client-only classes while they are being loaded into
the VM. This allows development-time deployments to succeed without
having to exclude them from the deployment. For production, we simply
exclude these same classes from the .war file (see the discussion
around `<packagingExcludes> for more details).

Next up, we configure `maven-war-plugin`, which produces the WAR file
during the build's _package_ phase:

[source,xml]
------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>${maven.war.plugin.version}</version>

        <executions>
          <execution>
            <phase>compile</phase>
            <goals>
              <goal>exploded</goal>
            </goals>
          </execution>
        </executions>
        
        <configuration>
          <warName>${project.artifactId}</warName>
          <outputFileNameMapping>@{artifactId}@-@{baseVersion}@@{dashClassifier?}@.@{extension}@</outputFileNameMapping>
          <packagingExcludes>**/client/**/*.class</packagingExcludes>
        </configuration>
      </plugin>
------

The first configuration tweak changes the name of the generated WAR
file to just __projectname__.war rather than the default
__projectname__-__version__.war. We find this more convenient to work
with, because the deployment URL remains stable that way. If you
prefer to have the version number in the WAR file name, feel free to
omit the `<warName>` setting.

The `<outputFileNameMapping>` tells the WAR plugin exactly what names
to give JAR files it copies into `target/WEB-INF/lib/`. This is
necessary because Eclipse and Maven sometimes use slightly different
names, and you end up with duplicate libraries on your classpath. This
duplication can cause ``Ambiguous bean reference'' errors from Weld
when your server-side app is starting up.

The `<packagingExcludes>` setting is vital: this keeps the
client-side-only classes off the web server. Anything that scans your
webapp for annotated classes or classes of a certain type (such as
Hibernate and Weld) tends to trip over classes that refer to GWT types
that only make sense in the client environment, such as Widgets and
JavaScript Native Methods. We'll get to these topics later, but for
now, just be sure to exclude your client-only classes from the .war
file.

The `<packagingExcludes>` setting accepts a comma-separated list of
patterns, so if you need to exclude more stuff later on, you can.

Now on to the clean configuration:

[source,xml]
------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-clean-plugin</artifactId>
        <version>${maven.clean.plugin.version}</version>
        <configuration>
          <filesets>
            <fileset>
              <directory>${basedir}</directory>
              <includes>
                <include>www-test/**</include>
                <include>.gwt/**</include>
                <include>.errai/**</include>
                <include>src/main/webapp/WEB-INF/deploy/**</include>
                <include>src/main/webapp/WEB-INF/lib/**</include>

                <!-- If you rename your GWT module, you MUST update this too -->
                <include>src/main/webapp/UberFireTutorial/**</include>

                <include>**/gwt-unitCache/**</include>
                <include>**/*.JUnit/**</include>
                <include>monitordb.*</include>
              </includes>
            </fileset>
          </filesets>
        </configuration>
      </plugin>
------

So yeah, the GWT tools (compiler, Dev Mode, and the JUnit test
harness) generate a lot of junk in a lot of places. Errai also
generates junk, but it's a bit more polite and keeps it all under one
directory called `.errai`.

The one thing to keep in mind here is the commented line: if you
rename your GWT module (which we'll talk about in the next section)
you will also have to update this line to match. If the `mvn clean`
command fails to remove your generated GWT module directory, you will
run into the dreaded ``Module _YourModule_ may need to be
(re)compiled'' error.

And now on to the WildFly plugin:

[source,xml]
------
      <plugin>
        <groupId>org.wildfly.plugins</groupId>
        <artifactId>wildfly-maven-plugin</artifactId>
        <version>1.0.1.Final</version>
        <configuration>
          <filename>${project.artifactId}.war</filename>
          <jvmArgs>-Dorg.jboss.weld.nonPortableMode=true</jvmArgs>
        </configuration>
        <executions>
          <execution>
            <id>start-wildfly</id>
            <phase>pre-integration-test</phase>
            <goals>
              <goal>start</goal>
              <goal>deploy-only</goal>
            </goals>
          </execution>
          <execution>
            <id>stop-wildfly</id>
            <phase>post-integration-test</phase>
            <goals>
              <goal>undeploy</goal>
              <goal>shutdown</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
------

This plugin is capable of starting and stopping a WildFly server,
deploying a project to that server, and even downloading a copy of
WildFly from Maven Central. We don't use this plugin with GWT
development mode (we use Errai's JBossLauncher for that), but we do
use it for integration testing the application with Selenium. As you
can see from the two executions of this plugin, we start the server
and deploy the app during the pre-integration-test phase, then
undeploy and shut down in the post-integration-test phase.

Speaking of integration testing, `maven-failsafe-plugin` covers the
rest of the setup:

[source,xml]
------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-failsafe-plugin</artifactId>
        <version>2.17</version>
        <configuration>
          <includes>
            <include>**/integration/*.java</include>
          </includes>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>integration-test</goal>
              <goal>verify</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
------

Even if you are familiar with Maven, you may not have encountered
`maven-failsafe-plugin` before. It is the integration testing
counterpart to `maven-surefire-plugin`, which is for unit testing.
The two plugins are nearly identical: they support the same testing
frameworks (JUnit, TestNG, and Maven's own convention-based testing
system) and most of the same options. The main difference is that
failsafe splits running tests and verifying results into two separate
goals. This allows tasks that you bind to `post-integration-test` to
run before the build is aborted.

Fitting this together with our configuration of the WildFly plugin,
here's how it plays out across Maven's four integration-testing goals:

. `pre-integration-test`: start wildfly; deploy application
. `integration-test`: run tests, storing results under `target`
. `post-integration-test`: undeploy app; stop wildfly
. `verify`: read the test results that were generated in step 2; fail
  the build if there are any test failures among the results

The reason this is a four-step process in Maven is to ensure that the
`post-integration-test` tasks are always executed. This ensures any
resources allocated in `pre-integration-test` are not leaked when the
tests fail.

Finally, note that we have told the failsafe plugin to run all the
tests in packages whose names end with ".integration". The last part
of our testing setup is to tell the surefire plugin to run everything
_but_ these tests:

[source,xml]
------
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.9</version>
        <configuration>
          <excludes>
            <exclude>**/*$*</exclude>
            <exclude>**/integration/*</exclude>
          </excludes>
        </configuration>
      </plugin>
------

Phew! That's it for the `<plugins>` section.

Just one more section to go, and you can skip it if nobody will even
use Eclipse to develop your project.

The `<pluginManagement>` section goes inside the `<build>` section
(it's a sibling of <plugins>, not a child).

[source,xml]
------
    <pluginManagement>
      <plugins>
        <!--This plugin's configuration is used to store Eclipse m2e settings 
          only. It has no influence on the Maven build itself. -->
        <plugin>
          <groupId>org.eclipse.m2e</groupId>
          <artifactId>lifecycle-mapping</artifactId>
          <version>1.0.0</version>
          <configuration>
            <lifecycleMappingMetadata>
              <pluginExecutions>
                <pluginExecution>
                  <pluginExecutionFilter>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>gwt-maven-plugin</artifactId>
                    <versionRange>[2.4.0,)</versionRange>
                    <goals>
                      <goal>resources</goal>
                    </goals>
                  </pluginExecutionFilter>
                  <action>
                    <ignore></ignore>
                  </action>
                </pluginExecution>
                <pluginExecution>
                  <pluginExecutionFilter>
                    <groupId>org.codehaus.mojo</groupId>
                    <artifactId>build-helper-maven-plugin</artifactId>
                    <versionRange>[1.7,)</versionRange>
                    <goals>
                      <goal>add-source</goal>
                    </goals>
                  </pluginExecutionFilter>
                  <action>
                    <ignore></ignore>
                  </action>
                </pluginExecution>
              </pluginExecutions>
            </lifecycleMappingMetadata>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
------

As the comment says, this is actually some Eclipse-specific
configuration that's stored in the POM. It doesn't have any effect on
the build if you're not in Eclipse.

If you plan on developing against Errai or UberFire snapshot releases
(these are published continuously during the development cycle, and
are the easiest way to get access to the latest features and fixes
available), add this section after the end of the `<build>` section:

[source,xml]
------
  <repositories>
    <repository>
      <id>jboss-public-repository-group</id>
      <name>JBoss Public Repository Group</name>
      <url>http://repository.jboss.org/nexus/content/groups/public/</url>
      <layout>default</layout>
      <releases>
        <enabled>true</enabled>
        <updatePolicy>never</updatePolicy>
      </releases>
      <snapshots>
        <enabled>true</enabled>
        <updatePolicy>daily</updatePolicy>
      </snapshots>
    </repository>
  </repositories>
------

Note that a lot of people feel it is
http://blog.sonatype.com/2009/02/why-putting-repositories-in-your-poms-is-a-bad-idea/[a
bad idea to include a `repositories` section in a project pom]. If you
share this feeling, feel free to put this section in your settings.xml
instead.

== Set up a .gitignore (or similar for your VCS)

It's important to avoid tracking generated files in source
control. When you accidentally check in a generated file, it will lead
to bad things in the future: merge conflicts, confusion, and coworkers
hitting you on the head with rubber chickens.

Here's the set of files you want your version control system to
ignore. This can be used as-is in a `.gitignore` file, but it should
be easy to adapt to the VCS you're using:

------
.apt_generated/
.classpath
.errai/
.factorypath
.niogit/
.project
.settings/
target/
war/
gwt-unitCache/
.apt_generated/
.project
*.iml
nb-configuration.xml
script.tmp
.idea
------

== Set up the web.xml

The `web.xml` file is the main and most fundamental configuration file
for your web application. In Java EE talk, it's your ``deployment
descriptor.''

Here's what you need in a typical UberFire `web.xml`:

.Create src/main/webapp/WEB-INF/web.xml
[source,xml]
------
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">

  <filter>
    <filter-name>PicketLink Authentication Filter</filter-name>
    <filter-class>org.picketlink.authentication.web.AuthenticationFilter</filter-class>

    <init-param>
      <param-name>authType</param-name>
      <param-value>org.jboss.errai.security.server.FormAuthenticationScheme</param-value>
    </init-param>
    <init-param>
      <param-name>form-login-page</param-name>
      <param-value>/login.jsp</param-value>
    </init-param>
    <init-param>
      <param-name>host-page</param-name>
      <param-value>/tutorial.html</param-value>
    </init-param>
    <init-param>
      <param-name>forceReAuthentication</param-name>
      <param-value>true</param-value>
    </init-param>
  </filter>

  <filter-mapping>
    <filter-name>PicketLink Authentication Filter</filter-name>
    <url-pattern>/tutorial.html</url-pattern>
  </filter-mapping>

  <filter-mapping>
    <filter-name>PicketLink Authentication Filter</filter-name>
    <url-pattern>*.erraiBus</url-pattern>
  </filter-mapping>

  <filter-mapping>
    <filter-name>PicketLink Authentication Filter</filter-name>
    <url-pattern>/uf_security_check</url-pattern>
  </filter-mapping>

  <servlet>
    <servlet-name>ErraiServlet</servlet-name>
    <servlet-class>org.jboss.errai.bus.server.servlet.DefaultBlockingServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>ErraiServlet</servlet-name>
    <url-pattern>*.erraiBus</url-pattern>
  </servlet-mapping>

  <welcome-file-list>
    <welcome-file>login.jsp</welcome-file>
  </welcome-file-list>

</web-app>
------

The following subsections examine the contents of `web.xml` in detail.

=== PicketLink security filter

For this demo, we are using PicketLink's AuthenticationFilter to
handle form-based login requests (`/uf_security_check`), and to ensure
that only authenticated users can access the Errai Bus (`*.erraiBus`)
and the GWT Host Page (`/tutorial.html`).

In addition to these three filter mappings, we give the filter the
following init params:

authType::
 PicketLink's filter supports pluggable authentication schemes, and we
 are using one such scheme which is bundled with Errai.
form-login-page::
 Tells Errai's auth scheme where to redirect to when there is an
 unauthenticated request to the host page. Mandatory when using
 Errai's auth scheme.
host-page::
 Tells the filter where to redirect to after a successful login
 attempt. Also, unauthenticated requests to the host page receive a
 redirect to the login page, whereas all other unauthenticated
 requests receive a 403 response. This parameter is mandatory when
 using Errai's auth scheme.
forceReAuthentication::
 Tells PicketLink that when there is a login attempt on an
 already-authenticated session (as will happen if you navigate back to
 the login page without signing out), it should sign out the current
 user and attempt a fresh login. By default, the auth filter reports
 an error in this scenario and leaves the current user logged in.

Note that the Errai auth scheme also uses a cookie to communicate the
current username and role memberships to the host page. See the
section about ErraiApp.properties to learn how to configure the client
to pay attention to this cookie.

=== Errai servlet

The ErraiServlet manages the communication bus that allows
two-way-push communication between the client and the server. It
is configured to handle all requests to *.erraiBus.


== Create an empty beans.xml

In CDI 1.0, the container checks for the existence of the file
`WEB-INF/beans.xml` before activating CDI for a particular web app
context. In CDI 1.1 containers, CDI is enabled everywhere by default,
so this is actually an optional step if you only intend to deploy to a
CDI 1.1 container.

.Create src/main/webapp/WEB-INF/beans.xml
[source,xml]
------
------

The file can contain CDI settings, but it can also be completely
empty as this one is!


== Set up Dev Mode logging

UberFire and Errai both use slf4j for logging. As mentioned earlier,
JBoss EAP and WildFly provide both the slf4j API and the JBoss Logging
implementation to webapps. By default, messages are logged to the
console where the server was started. You configure server-side
logging levels via the server's jboss-logging subsystem (and you can
even change them at runtime!)

However, code running in Dev Mode and during the GWT compile phase
while building your app still has some logging activity that you may
be interested in, and jboss-logging isn't present in those
environments. For these cases, we'll use slf4j-simple.

.Create src/main/resources/simplelogger.properties
------
# logging configuration for slf4j-simple
#
# This only affects GWT Dev Mode and GWT compiles!
# To configure server-side logging, use the JBoss Logging subsystem in EAP or WildFly.

org.slf4j.simpleLogger.logFile=System.out

org.slf4j.simpleLogger.defaultLogLevel=info

# Some logging categories that may be of interest when troubleshooting:
#org.slf4j.simpleLogger.log.org.jboss.errai.reflections=debug
#org.slf4j.simpleLogger.log.org.jboss.errai.ioc.rebind.ioc.bootstrapper=debug
#org.slf4j.simpleLogger.log.ClasspathScanning=debug
#org.slf4j.simpleLogger.log.ErraiMarshalling=debug
------

NOTE: Errai's JBossLauncher that starts and stops the server for Dev
Mode uses a fresh copy of the `standalone-full` configuration file
every time the server is started. This means that changes you make
through the GUI tools at runtime will not persist through the next
launch of Dev Mode. To make permanent changes to the logging
configuration, edit the file
`$JBOSS_HOME/standalone/configuration/standalone-full.xml` and restart
dev mode.


== Set up Errai classpath scanning and preferences

Errai optimizes its scanning of the classpath by doing a two-phase
scan: first, a shallow scan for classpath locations (.jar files and
directories) that contain an `ErraiApp.properties` file at their root;
then in the second phase, Errai does a deep scan of everything under
these specially marked locations. We need to mark our own application
as a "classpath entry of interest to Errai".

.Create src/main/resources/ErraiApp.properties
------
# ErraiApp.properties
#
# Do not remove, even if empty!
#

# This is a marker file. When it is detected inside a JAR or at the
# top of any classpath, the subdirectories are scanned for deployable
# components. As such, all Errai application modules in a project
# should contain an ErraiApp.properties at the root of all classpaths
# that you wish to be scanned.
#
# There are also some configuration options that can be set in this
# file, although it is rarely necessary. See the documentation at
# https://github.com/errai/errai/blob/master/errai-docs/src/main/asciidoc/reference.asciidoc#erraiappproperties
# for details.

errai.security.user_on_hostpage_enabled=true
------

Since we want Errai's client-side security system to pay attention to
the user information cookie that was sent by the authentication
filter, we've included that configuration parameter here too.

Note that the user cookie is only used to make client application
startup less chatty: from this cookie, the client app already knows
who is logged in. This allows the user interface to be built without
the extra delay of an RPC request to find out the current user's name
and roles. The cookie does not contain sufficient information to
identify the client to the server; for this, we rely on the JSESSIONID
cookie just like any other Servlet-based webapp.

== Set up example PicketLink users

=== Define example users and roles

For the demo, we'll populate PicketLink with a hard-coded set of users
and roles before the first login request is serviced.

.Create src/main/java/com/mycompany/uftutorial/server/PicketLinkDefaultUsers.java
[source,java]
------
/**
 * JBoss, Home of Professional Open Source
 * Copyright 2014, Red Hat, Inc. and/or its affiliates, and individual
 * contributors by the @authors tag. See the copyright.txt in the
 * distribution for a full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mycompany.uftutorial.server;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import javax.inject.Inject;

import org.picketlink.authentication.event.PreAuthenticateEvent;
import org.picketlink.idm.IdentityManager;
import org.picketlink.idm.PartitionManager;
import org.picketlink.idm.RelationshipManager;
import org.picketlink.idm.credential.Password;
import org.picketlink.idm.model.basic.Grant;
import org.picketlink.idm.model.basic.Role;
import org.picketlink.idm.model.basic.User;

@ApplicationScoped
public class PicketLinkDefaultUsers {

  @Inject
  private PartitionManager partitionManager;

  private boolean alreadyDone = false;

  public synchronized void create( @Observes PreAuthenticateEvent event ) {
    if ( alreadyDone ) {
      return;
    }

    alreadyDone = true;

    final IdentityManager identityManager = partitionManager.createIdentityManager();
    final RelationshipManager relationshipManager = partitionManager.createRelationshipManager();

    User admin = new User("admin");

    admin.setEmail("john@doe.com");
    admin.setFirstName("John");
    admin.setLastName("Doe");

    User regular = new User("regular");

    regular.setEmail("regular@example.com");
    regular.setFirstName("Regular");
    regular.setLastName("User");

    identityManager.add(admin);
    identityManager.add(regular);
    identityManager.updateCredential(admin, new Password("admin"));
    identityManager.updateCredential(regular, new Password("123"));

    Role roleDeveloper = new Role("simple");
    Role roleAdmin = new Role("admin");

    identityManager.add(roleDeveloper);
    identityManager.add(roleAdmin);

    relationshipManager.add(new Grant(admin, roleDeveloper));
    relationshipManager.add(new Grant(admin, roleAdmin));
  }

}
------

.Don't try this at home (or work!)
NOTE: Of course, this is just a demo setup. In a real-world application, you
will delegate the storage of users, passwords, and role memberships to
some central authentication service. PicketLink supports many such
setups, both federated and standalone, including SAML, LDAP, and user
info stored in JPA entities. Once you have worked through the rest of
this tutorial, you may want to circle back and connect this tutorial
application to your auth service of choice. See
http://docs.jboss.org/picketlink/2/latest/reference/html/[the
PicketLink User Guide] for information on how.

=== Create a login.jsp

We've set up some users, passwords, and roles. But how do we initiate
a login request?

The form-based authentication scheme we plugged into the PicketLink
filter works similarly to the form-based authentication available in
the Java Servlet specification: a POST request to the URL
`uf_security_check` with form parameters `uf_username` and
`uf_password` constitutes a login request. We'll create a `login.jsp`
page with a form which submits the correct information to this special
URL.

.Create `src/main/webapp/login.jsp`:
[source,html]
------
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>UberFire Tutorial</title>

  <style type="text/css">
    * {
      font-family: Helvetica, Arial, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      color: #fff;
      background:
      url('UberFireTutorial/images/bg-login.png')
      repeat #1b1b1b;
      font-size: 14px;
      text-shadow: #050505 0 -1px 0;
      font-weight: bold;
    }

    li {
      list-style: none;
    }

    #dummy {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 3px #777973;
      height: 250px;
      width: 100%;
      background:
      url('UberFireTutorial/images/bg-login-top.png')
      repeat #fff;
      z-index: 1;
    }

    #dummy2 {
      position: absolute;
      top: 0;
      left: 0;
      border-bottom: solid 2px #545551;
      height: 252px;
      width: 100%;
      background: transparent;
      z-index: 2;
    }

    #login-wrapper {
      margin: 0 0 0 -160px;
      width: 320px;
      text-align: center;
      z-index: 99;
      position: absolute;
      top: 0;
      left: 50%;
    }

    #login-top {
      height: 120px;
      width: 401px;
      padding-top: 20px;
      text-align: center;
    }

    #login-content {
      margin-top: 120px;
    }

    label {
      width: 70px;
      float: left;
      padding: 8px;
      line-height: 14px;
      margin-top: -4px;
    }

    input.text-input {
      width: 200px;
      float: right;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      background: #fff;
      border: solid 1px transparent;
      color: #555;
      padding: 8px;
      font-size: 13px;
    }

    input.button {
      float: right;
      padding: 6px 10px;
      color: #fff;
      font-size: 14px;
      background: -webkit-gradient(linear, 0% 0%, 0% 100%,
      from(#a4d04a), to(#459300));
      text-shadow: #050505 0 -1px 0;
      background-color: #459300;
      -moz-border-radius: 4px;
      -webkit-border-radius: 4px;
      border-radius: 4px;
      border: solid 1px transparent;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
    }

    input.button:hover {
      background: -webkit-gradient(linear, 0% 0%, 0% 100%,
      from(#a4d04a), to(#a4d04a), color-stop(80%, #76b226));
      text-shadow: #050505 0 -1px 2px;
      background-color: #a4d04a;
      color: #fff;
    }

    div.error {
      padding: 8px;
      background: rgb(52, 4, 0);
      -moz-border-radius: 8px;
      -webkit-border-radius: 8px;
      border-radius: 8px;
      border: solid 1px transparent;
      margin: 6px 0;
    }
  </style>
</head>

<body id="login">

<div id="login-wrapper" class="png_bg">
  <div id="login-top">
    <img src="UberFireTutorial/images/uf_logo.png" alt="UberFire Logo"
  title="Powered By UberFire"/>
  </div>

  <div id="login-content">
    <form action="uf_security_check" method="post">
      <p>
        <label>Username</label>
        <input value="" name="uf_username" class="text-input"
    type="text"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <label>Password</label>
        <input name="uf_password" class="text-input" type="password"/>
        <br style="clear: both;"/>
      </p>

      <p>
        <% if (request.getParameter("gwt.codesvr") != null) { %>
          <input type="hidden" name="gwt.codesvr" value="<%=
        org.owasp.encoder.Encode.forHtmlAttribute(request.getParameter("gwt.codesvr"))
        %>"/>
        <% } %>
        <input class="button" type="submit" value="Sign In"/>
      </p>
    </form>
    <% if (request.getParameter("login_failed") != null) { %>
    <div class="error">
      Login Failed. Please try again.
    </div>
    <% } %>
  </div>
</div>
<div id="dummy"></div>
<div id="dummy2"></div>
</body>
</html>
------

The important part of this file is the form that posts `uf_username`
and `uf_password` to the `uf_security_check` URL. This will be
recognized by our custom auth scheme as a login attempt.

The hidden parameter `gwt.codesvr` is there to ensure a request
initiating from GWT's Dev Mode remains a Dev Mode request after the
login completes (this parameter triggers the Dev Mode plugin in the
browser).


== Set up the VFS

Before we turn to the client side of our application, there's one more
server-side piece that needs to be configured: the Virtual File System
(VFS) provider.

UberFire's Workbench GUI module relies on the UberFire VFS for storing
perspective definitions, perspective geometries, editor-to-filename
associations, and more.

=== Select the file system providers

You select the UberFire's VFS implementations the same way as you
choose UberFire security components: using Java's Service Loader
mechanism. So create the file
`src/main/resources/META-INF/services/org.uberfire.java.nio.file.spi.FileSystemProvider`
and put the following line into it:

------
org.uberfire.java.nio.fs.jgit.JGitFileSystemProvider
org.uberfire.java.nio.fs.file.SimpleFileSystemProvider
------

This tells UberFire to use its git-based filesystem as the default VFS
(because it is first in the list), and also registers the simple
filesystem provider. The simple filesystem provider is not optional;
it is required for temporary files.


== Create the GWT host page

As mentioned earlier, GWT apps need a _host page_ that points the
browser at their main __ModuleName__.nocache.js file.

.Create src/main/webapp/tutorial.html
[source,html]
------
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>UberFire Showcase</title>
  <link rel="stylesheet" href="UberFireTutorial/css/uberfire-loading.css">
  <link rel="stylesheet" href="UberFireTutorial/css/uberfire-showcase.css">
  <link rel="stylesheet" href="UberFireTutorial/css/ruleflow.css">
</head>
<body>

  <!-- loading indicator to display while the app is being loaded -->
  <div id="loading">
    <div class="loading-indicator">
      <img src="UberFireTutorial/images/loading-icon.gif" width="32" height="32"
           style="margin-right: 8px; float: left; vertical-align: top;">
        Please wait<br/>
        <span id="loading-msg">Loading application...</span>
    </div>
  </div>

  <!-- The GWT js file generated at compile time -->
  <script type="text/javascript" src='UberFireTutorial/UberFireTutorial.nocache.js'></script>
</body>
</html>
------

== Create a client-side entry point class

Okay, enough mucking around with directory structure and configuration
files! We went through all of that because it's important to
understand everything you put into your web application, and doing
something is the best way to learn it. In the future, you'll probably
want to just start with a copy of a working demo app and delete the
parts you don't need.

An _entry point_ is a place where a program starts its execution. In
JavaSE programs, the entry point is the famous `public static void
main(String[] args)` method. In a Java EE environment, you typically
have many entry points: every Servlet and JAX-RS resource method is an
entry point into the application.

In an UberFire application, there are typically _client side_
components (the parts that are translated to JavaScript and execute in
the browser) and _server side_ components (the parts that are compiled
to class files and deployed in the war file.)

Any class in a client-only package of your application can be a
client-side entry point into your application. To designate a
client-side class as an entry point, annotate it with
`@EntryPoint`.

.Create src/main/java/com/mycompany/uftutorial/client/ClientEntryPoint.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.enterprise.event.Observes;

import org.jboss.errai.ioc.client.api.EntryPoint;
import org.uberfire.client.workbench.events.ApplicationReadyEvent;

import com.google.gwt.animation.client.Animation;
import com.google.gwt.dom.client.Element;
import com.google.gwt.dom.client.Style;
import com.google.gwt.user.client.ui.RootPanel;

@EntryPoint
public class ClientEntryPoint {

  /**
   * Gets invoked late in the startup sequence, when all UberFire framework
   * bootstrapping has completed.
   */
  private void finalInit(@Observes final ApplicationReadyEvent event) {
    hideLoadingPopup();
  }

  /**
   * Fades out the "Loading application" pop-up which was included in the host
   * page by UberFireServlet.
   */
  private void hideLoadingPopup() {
    final Element e = RootPanel.get( "loading" ).getElement();

    new Animation() {

      @Override
      protected void onUpdate( double progress ) {
        e.getStyle().setOpacity( 1.0 - progress );
      }

      @Override
      protected void onComplete() {
        e.getStyle().setVisibility( Style.Visibility.HIDDEN );
      }
    }.run( 500 );
  }

}
------

The `@EntryPoint` annotation tells the framework that the class is a
CDI Bean that should be instantiated when the page is loaded into the
browser. You can name an entry point class anything you like. You can
create as many `@EntryPoint` classes as you want, but you can't
specify what order they will be instantiated in. Usually, you'll just
have one.

The `finalInit()` method is a CDI observer method. The UberFire
Workbench framework fires an `ApplicationReadyEvent` when the
framework has finished initializing. This happens very late in the
startup process of the client application, so it's a good place to
manipulate the UI or kick off RPC requests to the server.

NOTE: In Errai and UberFire, it's a common pitfall to use the CDI
`@PostConstruct` annotation on the method that runs your
initialization code. This does not work in practice because it's
usually invoked too early: before many parts of the framework
(including the Errai communication bus and UberFire's Place Manager)
have had a chance to initialize. Stick with observing
`ApplicationReadyEvent` and you'll be fine.

Right now, our `finalInit()` method just hides a `<div>` element that
was present in the host page template served by UberFireServlet. What
else might we put in there for bootstrapping an UberFire app? Let's
first create a panel and come back to that question later.

== Create a Workbench Screen

UberFire interfaces are made of some fundamental building blocks:
Widgets, Layout Panels, Screens, Workbench Panels, Menu Bars, Tool
Bars, and Perspectives. Layout Panels can contain Widgets and other
Layout Panels; Perspectives contain Workbench Panels, an optional Menu
Bar, and an optional Tool Bar. Perspectives split up the screen into
multiple resizeable regions, and end users can drag and drop Panels
between these regions to customize their workspace.

Start by creating this new source file:

.Create src/main/java/com/mycompany/uftutorial/client/HelloWorldScreen.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.annotation.PostConstruct;
import javax.enterprise.context.Dependent;
import javax.enterprise.event.Observes;
import javax.inject.Inject;

import org.jboss.errai.security.client.local.api.SecurityContext;
import org.uberfire.client.annotations.WorkbenchPartTitle;
import org.uberfire.client.annotations.WorkbenchPartView;
import org.uberfire.client.annotations.WorkbenchScreen;

import com.google.gwt.user.client.ui.IsWidget;
import com.google.gwt.user.client.ui.Label;

@Dependent
@WorkbenchScreen(identifier =
"com.mycompany.uftutorial.client.HelloWorldScreen")
public class HelloWorldScreen {

  @Inject
  private SecurityContext securityContext;

  private final Label label = new Label();

  @PostConstruct
  private void init() {
    label.setText(getInitialLabelText());
  }

  @WorkbenchPartTitle
  public String getTitle() {
    return "Greetings";
  }

  @WorkbenchPartView
  public IsWidget getView() {
    return label;
  }

  private String getInitialLabelText() {
    return "Hello, " + securityContext.getCachedUser().getIdentifier()
    + ". Welcome to UberFire!";
  }
}
------

The class itself is a CDI bean with one injected field and a second
field that's created and managed explicitly. But whether or not we're
faimilar with CDI, we're seeing a bunch of annotations for the first
time. Let's examine them one by one.

@Dependent::

 Marks this class as a _dependent scoped CDI bean_ that should be
 freshly instantiated every time a new instance is called
 for. Contrast with `@ApplicationScoped`, which marks a CDI bean that
 should be created only one time over the life of the application.

@WorkbenchScreen::

 Tells UberFire that the class defines a Screen in the application.

@Inject::

 Tells the CDI container it's responsible for finding an instance of a
 compatible type, and assigning it to the field before invoking any
 methods on this object.

@PostConstruct::

 Actually, we already saw this one in our entry point class. This CDI
 annotation tells the container to invoke the method after all
 injections have been satisfied, and before any other part of the
 application is given a reference to the object.

@WorkbenchPartTitle::

 Denotes the method that returns the Screen's title. Every Screen must
 have a `@WorkbenchPartTitle` method.

@WorkbenchPartView::

 Denotes the method that returns the Panel's view. The view can be any
 class that extends GWT's `Widget` class or implements GWT's
 `IsWidget` interface. In this example, we're returning a GWT `Label`,
 which is a GWT API for a `<div>` element with text in it. Every
 Screen must either have a `@WorkbenchPartView` method, extend
 `Widget`, or implement `IsWidget`.

.About Client-Side Scopes
NOTE: CDI scopes in the client side are tied to the lifecycle of the
web page in the browser, not the lifecycle of the server-side web
application. In the client, the Application Scope begins when the page
is first loaded, and ends when when the user navigates away from the
page--either by visiting a different URL, or by closing the browser
window/tab. Currently, the Session and Conversation scopes are not
defined on the client side.

== Define a perspective

Now we have a Screen, but nowhere to put it. Remember, the UberFire
workbench UI is arranged as Workbench -> Perspective -> Workbench
Panel -> Screen. Perspectives dictate the position and size of
Workbench Panels. We need to define a Perspective.

.Create src/main/java/com/mycompany/uftutorial/client/HomePerspective.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.ApplicationScoped;

import org.uberfire.client.annotations.Perspective;
import org.uberfire.client.annotations.WorkbenchPerspective;
import org.uberfire.client.workbench.panels.impl.MultiTabWorkbenchPanelPresenter;
import org.uberfire.mvp.impl.DefaultPlaceRequest;
import org.uberfire.workbench.model.PanelType;
import org.uberfire.workbench.model.PerspectiveDefinition;
import org.uberfire.workbench.model.impl.PartDefinitionImpl;
import org.uberfire.workbench.model.impl.PerspectiveDefinitionImpl;

@ApplicationScoped
@WorkbenchPerspective(
        identifier =
	"com.mycompany.uftutorial.client.HomePerspective",
        isDefault = true)
public class HomePerspective {

  @Perspective
  public PerspectiveDefinition getPerspective() {
    final PerspectiveDefinition p = new PerspectiveDefinitionImpl(MultiTabWorkbenchPanelPresenter.class.getName());
    p.setName(getClass().getName());
    p.getRoot().addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(HelloWorldScreen.class.getName())));

    return p;
  }

}
------

Once again, we're encountering some new annotations:

@ApplicationScoped::

 Tells the CDI container that it should only create one instance of
 the class over the life of the application. This one instance will be
 used to satisfy every `@Inject` point in the app.

@WorkbenchPerspective::

 Tells UberFire that the class defines a perspective.

@Perspective::

 Tells UberFire that this method returns the PerspectiveDefinition
 that governs the perspective's layout and default contents. Every
 `@WorkbenchPerspective` class needs a method annotated with
 `@Perspective`.


== Define a GWT module

So we created some client-side Java code and some server-side Java
code, but how will the GWT compiler know the difference? How can it
tell what's supposed to be packaged up for running on the browser, and
what it should ignore?  That's where GWT modules come in.


.Create src/main/java/com/mycompany/uftutorial/UberFireTutorial.gwt.xml
[source,xml]
------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE module PUBLIC "-//Google Inc.//DTD Google Web Toolkit 2.5//EN"
        "http://google-web-toolkit.googlecode.com/svn/releases/2.5/distro-source/core/src/gwt-module.dtd">

<!-- If you rename the module, update the maven-clean-plugin
     configuration in pom.xml and the .gitignore file. -->
<module rename-to="UberFireTutorial">

  <inherits name="org.jboss.errai.enterprise.All"/>

  <inherits name="org.uberfire.UberfireJS"/>

  <inherits name="org.uberfire.security.UberfireSecurityClient"/>

  <inherits name="org.uberfire.UberfireWorkbench"/>
  <inherits name="org.uberfire.UberfireBackend"/>

  <source path="client"/>
  <source path="shared"/>
</module>
------

What is all this? Let's step through it.

The root element of a GWT module descriptor is `<module>`. The default
name of a module is a fully-qualified name that includes the Java
package it sits in. For example, this module's default name is
`com.mycompany.uftutorial.UberFireTutorial`. When we're creating a GWT
module for a deployable application, it's usually more convenient to
give it a simple, unqualified name. So we use the optional `rename-to`
attribute to give our module such a name.

Next, we see a series of `<inherits>` elements. These tell GWT which
other GWT modules our app depends on. Just like Maven dependencies,
modules can depend on other modules, and when you inherit one you
_transitively inherit_ all the modules it depends on.

Finally, there are two `<source>` paths defined. This is how you tell
GWT which packages it should translate to JavaScript. In our case, we
want GWT to translate everything under the
`com.mycompany.uftutorial.client` and
`com.mycompany.uftutorial.shared` packages.

.GWT does not manage the classpath!
TIP: When you inherit a GWT module, you're only telling the GWT
compiler that you intend to use code from that module--you're not
telling it where to find that module. You are responsible for ensuring
the module is on the classpath when the GWT compiler runs. So when you
inherit a GWT module, make sure it's also a dependency in your
pom.xml.

== Time to see it work!

We've come a long way since we started with that empty
directory. Let's reward all the hard work by starting our app and
seeing it do something!

......
$ mvn compile
$ mvn gwt:run
......

Eventually, the GWT Development Mode GUI will pop up. Wait for the
"Calculating..." button to change to "Launch in Default Browser," then
press that button.

=== Install the GWT Dev Mode browser plugin

If you've never developed a GWT application before, you'll be looking
at a prompt to install the Dev Mode plugin into your browser. Follow
the prompts and restart your browser when prompted.

TIP:FireFox versions 27 and higher no longer contain the plugin API
that Dev Mode requires. If you want to use FireFox as your
development-mode browser, it is recommended that you download the
http://download.cdn.mozilla.net/pub/mozilla.org/firefox/releases/24.2.0esr/[FireFox
24 extended support release.] You could also use FireFox 26 and
disable automatic updates.

=== Sign in

If you copied the PicketLinkDefaultUsers class as-is, you can sign in
as user "admin" with password "admin". Otherwise, use the username and
password you chose when creating that class.

=== Hello UberFire!

Now you should see your ``Hello UberFire'' label in the top left
corner of the page. Congratulations!

[TIP]
.Not Working?
======
At this point, your project should be more-or-less identical to the
Tutorial project at the
link:https://github.com/uberfire/uberfire-tutorial/tree/checkpoint-1[checkpoint-1
tag]. If your project isn't working at this point, grab that one and
compare yours with it.

......
$ git clone https://github.com/uberfire/uberfire-tutorial.git
$ cd uberfire-tutorial
$ git checkout checkpoint-1
......

Or grab link:https://github.com/uberfire/uberfire-tutorial/archive/checkpoint-1.zip[a zipfile of the sources].
======

== Create a second panel

Let's create a second panel so we can get a better feel for how
workbench perspectives and panels fit together.

This time, we'll create a screen backed by a simple model class to
demonstrate how you'd typically separate model from view in an
UberFire application. The model class will be called `Mood`, and it
will represent how the current user is feeling at the moment. The view
will be called `MoodScreen` and it will allow the user to update their
current mood.

=== Create the data model class

The data model in an UberFire app is typically represented by _Plain
Old Java Objects_, (_POJOs_). This leaves you the flexibility to use
them in other frameworks that like POJOs such as JPA, JAXB, Errai Data
Binding, and much more by adorning them with annotations. For now, our
extremely simple data model will just be an unadorned POJO.

.Create src/main/java/com/mycompany/uftutorial/shared/Mood.java
[source,java]
------
package com.mycompany.uftutorial.shared;

/**
 * Model class representing a user's mood.
 */
public class Mood {

  private final String text;

  public Mood(String text) {
    this.text = text;
  }

  public String getText() {
    return text;
  }

  @Override
  public String toString() {
    return text;
  }
}
------

=== Create MoodScreen, a Templated Widget

For MoodScreen, let's use the Errai UI Template system. This approach
is similar to GWT UiBinder, but it lets you create the template in a
plain HTML 5 file rather than a specialized UiBinder XML file.

First, create the template file:

.Create src/main/java/com/mycompany/uftutorial/client/MoodScreen.html
[source,html]
------
<!DOCTYPE html>
<div>
  <input id=moodTextBox type=text placeholder="How do you feel?">
</div>
------

This file will be used as a client-side template for the new
MoodScreen widget. Here's what that looks like:

.Create src/main/java/com/mycompany/uftutorial/client/MoodScreen.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.Dependent;
import javax.enterprise.event.Event;
import javax.inject.Inject;

import org.jboss.errai.ui.shared.api.annotations.DataField;
import org.jboss.errai.ui.shared.api.annotations.EventHandler;
import org.jboss.errai.ui.shared.api.annotations.Templated;
import org.uberfire.client.annotations.WorkbenchPartTitle;
import org.uberfire.client.annotations.WorkbenchScreen;

import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.event.dom.client.KeyDownEvent;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.TextBox;
import com.mycompany.uftutorial.shared.Mood;

@Dependent
@Templated
@WorkbenchScreen(identifier="com.mycompany.uftutorial.client.MoodScreen")
public class MoodScreen extends Composite {

  @Inject @DataField
  private TextBox moodTextBox;

  @Inject Event<Mood> moodEvent;

  @Override
  @WorkbenchPartTitle
  public String getTitle() {
    return "Change Mood";
  }

  @EventHandler("moodTextBox")
  private void onKeyDown(KeyDownEvent event) {
    if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
      moodEvent.fire(new Mood(moodTextBox.getText()));
      moodTextBox.setText("");
    }
  }
}
------

MoodScreen is very similar to HelloWorldScreen. The only structural
differences are related to our choice to use an Errai UI Template:
in addition to the UberFire Workbench class annotations (`@Dependent`
and `@WorkbenchScreen`), we've also used `@Templated`. This tells
Errai UI that this widget's layout is defined in the companion HTML
file `MoodScreen.html` in the same directory.

With Errai UI templating, we can use the `@DataField` annotation to
inject elements from the HTML file directly into our widget class. In
this case, we're injecting the `<input>` element as a GWT `TextBox`
widget.

We're also using Errai UI to attach an event handler to the text box:
the `onKeyDown` method has been set up to receive every `KeyDownEvent`
generated by `moodTextBox`. In this case, our event handler method is
set up to create a new Mood object from the contents of the text box
each time the user presses Enter. We fire this Mood object as a CDI
event as soon as it's been created. Who observes the event?  Nobody
yet, but we'll get to that soon!

There's more you can do with Errai UI templates. See the full
link:https://docs.jboss.org/author/display/ERRAI/Errai+UI[Errai
UI reference guide] for details.

=== Give MoodScreen a place in HomePerspective

Let's alter HomePerspective a little bit: we'll add a new panel on the
left-hand side and populate it with MoodScreen by default.

.Modify src/main/java/com/mycompany/uftutorial/client/HomePerspective.java
[source,java]
------
  @Perspective
  public PerspectiveDefinition getPerspective() {
    final PerspectiveDefinition p = new
    PerspectiveDefinitionImpl(MultiTabWorkbenchPanelPresenter.class.getName());
    p.setName(getClass().getName());

    p.getRoot().addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(HelloWorldScreen.class.getName())));

    PanelDefinitionImpl westPanel = new PanelDefinitionImpl(MultiListWorkbenchPanelPresenter.class.getName());
    p.getRoot().insertChild(CompassPosition.WEST, westPanel);
    westPanel.setWidth(250);
    westPanel.addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(MoodScreen.class.getName())));

    return p;
  }
------

=== Add a CDI observer to HelloWorldScreen

Now let's do something in HelloWorldScreen in response to the the
event we fire in MoodScreen when the user presses Enter. To do this
we'll add a CDI _observer method_.

.Add to src/main/java/com/mycompany/uftutorial/client/HelloWorldScreen.java
[source,java]
------
  public void onMoodChange(@Observes Mood mood) {
    label.setText("I understand you are feeling " + mood.getText());
  }
------

=== Refresh and see it work

Assuming you've left Dev Mode running, you should be able to pick up
these changes by refreshing the page in your browser.

If you've quit Dev Mode already, as a reminder, here's how you launch
it:

......
$ mvn compile gwt:run
......

[TIP]
.Not Working?
======
At this point, your project should be more-or-less identical to the
Tutorial project at the
link:https://github.com/uberfire/uberfire-tutorial/tree/checkpoint-2[checkpoint-2
tag]. If your project isn't working at this point, grab that one and
compare yours with it.

......
$ git clone https://github.com/uberfire/uberfire-tutorial.git
$ cd uberfire-tutorial
$ git checkout checkpoint-2
......

Or grab link:https://github.com/uberfire/uberfire-tutorial/archive/checkpoint-2.zip[a zipfile of the sources].
======

== Add a menu bar

Moving on, let's add a menu bar to our app.

Menu bars typically live at the top of the screen, and UberFire's
perspective layout system gives you a way to place widgets in just
that spot!

To add a widget to the top of the page, we simply create a CDI bean
that implements `Header`.

.Create src/main/java/com/mycompany/uftutorial/client/AppMenuBar.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.uberfire.client.mvp.PlaceManager;
import org.uberfire.client.workbench.Header;
import org.uberfire.client.workbench.widgets.menu.WorkbenchMenuBarPresenter;
import org.uberfire.mvp.Command;
import org.uberfire.workbench.model.menu.MenuFactory;
import org.uberfire.workbench.model.menu.Menus;

import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.Widget;

@ApplicationScoped
public class AppMenuBar extends Composite implements Header {

  @Inject
  private WorkbenchMenuBarPresenter menuBarPresenter;

  @Inject
  private PlaceManager placeManager;

  @Override
  public Widget asWidget() {
    return menuBarPresenter.getView().asWidget();
  }

  @Override
  public int getOrder() {
    return Integer.MAX_VALUE;
  }

  @Override
  public String getId() {
    return getClass().getName();
  }

  @PostConstruct
  private void initMenus() {
    Menus menus =
      MenuFactory.newTopLevelMenu("Screens")
        .menus()
          .menu("Hello Screen").respondsWith(makeGoToPlaceCommand(HelloWorldScreen.class)).endMenu()
          .menu("Mood Screen").respondsWith(makeGoToPlaceCommand(MoodScreen.class)).endMenu()
        .endMenus()
      .endMenu()
      .newTopLevelMenu("Other")
        .menus()
          .menu("Alert Box").respondsWith(new Command() {
              @Override
              public void execute() {
                Window.alert("Hi. I'm an Alert Box.");
              }
            }).endMenu()
        .endMenus()
      .endMenu()
    .build();

    menuBarPresenter.addMenus(menus);
  }

  private Command makeGoToPlaceCommand(final Class<?> placeClass) {
    return new Command() {
      @Override
      public void execute() {
        placeManager.goTo(placeClass.getName());
      }
    };
  }
}
------

Stepping through the code, we've implemented the `asWidget()` method,
which comes from the `Header` interface (`Header` extends `IsWidget`).
`asWidget()` returns the view from the injected
`WorkbenchMenuBarPresenter`. This is the widget that will appear
full-width across the top of the screen.

The `getOrder()` method comes from the Header interface as
well. UberFire supports any number of headers, and they are stacked
according to their order property. Higher-numbered headers appear
above lower-numbered headers. This menu bar returns the largest
possible ordering number, so it will always appear at the very top of
the screen even if there are other headers.

The `getId()` method also comes from the Header interface. Headers can
be selectively enabled and disabled by ID.

The `initMenus()` method is a `@PostConstruct` method, so it will be
invoked just after our AppMenuBar bean is created. This method uses
UberFire's fluent `MenuFactory` API to build a menu bar with two
top-level menus: ``Screens'' and ``Other.'' When a menu is clicked, it
relies on a `Command` callback to perform its action. For the items in
the ``Screens'' menu, we rely on the `makeScreenCommand()` subroutine
to build a command that shows the appropriate screen.

The ``Other'' menu repeats the pattern established in building the
``Screen'' menu, but it declares the Command callback inline since
it needs a one-off action.

=== See it work!

Time to refresh the browser again. If you left Dev Mode running, just
go to your browser and hit the refresh button!

[TIP]
.Not Working?
======
At this point, your project should be more-or-less identical to the
Tutorial project at the
link:https://github.com/uberfire/uberfire-tutorial/tree/checkpoint-3[checkpoint-3
tag]. If your project isn't working at this point, grab that one and
compare yours with it.

......
$ git clone https://github.com/uberfire/uberfire-tutorial.git
$ cd uberfire-tutorial
$ git checkout checkpoint-3
......

Or grab link:https://github.com/uberfire/uberfire-tutorial/archive/checkpoint-3.zip[a zipfile of the sources].
======

== Add a toolbar

[WARNING]
.Toolbars don't work in 0.4
======
There was a bug in UberFire 0.4 which made it impossible to add
items to a toolbar. This bug has been eliminated in the latest
0.4.0-SNAPSHOT releases and all 0.5 versions.
======

Toolbars typically also go near the top of the screen, so let's define
another `Header` component to house our toolbar.

.Create src/main/java/com/mycompany/uftutorial/client/AppToolBar.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.uberfire.client.workbench.Header;
import org.uberfire.client.workbench.widgets.toolbar.WorkbenchToolBarPresenter;

import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.Widget;

@ApplicationScoped
public class AppToolBar extends Composite implements Header {

  @Inject
  private WorkbenchToolBarPresenter toolBarPresenter;

  @Override
  public Widget asWidget() {
    return toolBarPresenter.getView().asWidget();
  }

  @Override
  public int getOrder() {
    return 0;
  }

  @Override
  public String getId() {
    return getClass().getName();
  }

}
------

This time we're returning an order index of 0, which will put the
toolbar at the bottom of the pile of headers (beneath the menu bar we
created earlier).

The view component we return for this header comes from the
`WorkbenchToolBarPresenter`, which automatically adjusts its contents
so it contains all the toolbar actions available for currently-open
places in the app.

.Add to src/main/java/com/mycompany/uftutorial/client/HelloWorldScreen.java
[source,java]
------
  @WorkbenchToolBar
  public ToolBar getToolBar() {
    ToolBar tb = new DefaultToolBar("hello-world-toolbar");
    tb.addItem(new DefaultToolBarItem(IconType.ASTERISK, "Reset Hello Screen", new Command() {
      @Override
      public void execute() {
        label.setText(getInitialLabelText());
      }
    }));
    return tb;
  }
------

=== See it work!

Time to refresh the browser again. If you left Dev Mode running, just
go to your browser and hit the refresh button!

This time, you should see a toolbar sandwiched between the menu bar
and the rest of the page's content. The toolbar should contain one
button with an asterisk icon on it. Every time you press the button,
the panel titled ``Greetings'' (the `HelloWorldScreen`) should reset
back to its initial message.

Notice also that if if you close the `HelloWorldScreen` that its
associated button disappears from the toolbar. Try it: press the close
(``X'') button in the ``Greetings'' titlebar, and the toolbar should
become empty. Now use the ``Screens'' menu to bring ``Hello Screen''
back, and its toolbar icon will rematerialize. Easy!

[TIP]
.Not Working?
======
At this point, your project should be more-or-less identical to the
Tutorial project at the
link:https://github.com/uberfire/uberfire-tutorial/tree/checkpoint-4[checkpoint-4
tag]. If your project isn't working at this point, grab that one and
compare yours with it.

......
$ git clone https://github.com/uberfire/uberfire-tutorial.git
$ cd uberfire-tutorial
$ git checkout checkpoint-4
......

Or grab
link:https://github.com/uberfire/uberfire-tutorial/archive/checkpoint-4.zip[a zipfile of the sources].
======


== Define a second perspective

Now let's define a second perspective that contains the same two
screens arranged in a different layout.

.Create src/main/java/com/mycompany/uftutorial/client/HorizontalPerspective.java
[source,java]
------
package com.mycompany.uftutorial.client;

import javax.enterprise.context.ApplicationScoped;

import org.uberfire.client.annotations.Perspective;
import org.uberfire.client.annotations.WorkbenchPerspective;
import
org.uberfire.client.workbench.panels.impl.MultiListWorkbenchPanelPresenter;
import org.uberfire.mvp.impl.DefaultPlaceRequest;
import org.uberfire.workbench.model.CompassPosition;
import org.uberfire.workbench.model.PerspectiveDefinition;
import org.uberfire.workbench.model.impl.PanelDefinitionImpl;
import org.uberfire.workbench.model.impl.PartDefinitionImpl;
import org.uberfire.workbench.model.impl.PerspectiveDefinitionImpl;

@ApplicationScoped
@WorkbenchPerspective(
        identifier =
	"com.mycompany.uftutorial.client.HorizontalPerspective")
public class HorizontalPerspective {

  @Perspective
  public PerspectiveDefinition getPerspective() {
    final PerspectiveDefinition p = new PerspectiveDefinitionImpl(MultiListWorkbenchPanelPresenter.class.getName());
    p.setName(getClass().getName());

    p.getRoot().addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(HelloWorldScreen.class.getName())));
    p.getRoot().setElementId("horizontal-rootPanel");

    PanelDefinitionImpl northPanel = new PanelDefinitionImpl(MultiListWorkbenchPanelPresenter.class.getName());
    p.getRoot().insertChild(CompassPosition.NORTH, northPanel);
    northPanel.setElementId("horizontal-northPanel");
    northPanel.setHeight(300);
    northPanel.addPart(
            new PartDefinitionImpl(
                    new DefaultPlaceRequest(MoodScreen.class.getName())));

    return p;
  }

}
------

This looks very much like what we did in `HomePerspective` except this
time we're docking the second panel at the north edge of the root
panel rather than the west.

To give ourselves a way to switch between the perspectives, let's add
a new top-level menu item:

.Modify src/main/java/com/mycompany/uftutorial/client/AppMenuBar.java
[source,java]
------
// (other methods remain unchanged)

  @PostConstruct
  private void initMenus() {
    Menus menus =
      MenuFactory.newTopLevelMenu("Screens")
        .menus()
          .menu("Hello Screen").respondsWith(makeGoToPlaceCommand(HelloWorldScreen.class)).endMenu()
          .menu("Mood Screen").respondsWith(makeGoToPlaceCommand(MoodScreen.class)).endMenu()
        .endMenus()
      .endMenu()
// BEGIN new code to insert
      .newTopLevelMenu("Perspectives")
        .menus()
          .menu("Home Perspective").respondsWith(makeGoToPlaceCommand(HomePerspective.class)).endMenu()
          .menu("Horizontal Perspective").respondsWith(makeGoToPlaceCommand(HorizontalPerspective.class)).endMenu()
        .endMenus()
      .endMenu()
// END new code to insert
      .newTopLevelMenu("Other")
        .menus()
          .menu("Alert Box").respondsWith(new Command() {
              @Override
              public void execute() {
                Window.alert("Hi. I'm an Alert Box.");
              }
            }).endMenu()
        .endMenus()
      .endMenu()
    .build();

    menuBarPresenter.addMenus(menus);
  }
------

Luckily, we get to reuse our `makeGoToPlaceCommand()` method for
creating the Command callbacks that switch between perspectives.

=== Time to see it work!

Refresh the browser window once again, and you should now see the new
Perspectives menu. Select "Horizontal Perspective" to press this new
perspective into action.

[TIP]
.Not Working?
======
At this point, your project should be more-or-less identical to the
Tutorial project at the
link:https://github.com/uberfire/uberfire-tutorial/tree/checkpoint-5[checkpoint-5
tag]. If your project isn't working at this point, grab that one and
compare yours with it.

......
$ git clone https://github.com/uberfire/uberfire-tutorial.git
$ cd uberfire-tutorial
$ git checkout checkpoint-5
......

Or grab
link:https://github.com/uberfire/uberfire-tutorial/archive/checkpoint-5.zip[a zipfile of the sources].
======
